**Лабораторна робота №5: Розробка коригувальних кодів Хеммінга**

---

## **1. Мета роботи**

- Ознайомитися з принципами побудови кодів Хеммінга.
- Реалізувати алгоритм побудови та перевірки Хеммінгового коду.
- Продемонструвати можливості виявлення та виправлення помилок у бітовому повідомленні.

## **2. Теоретичні відомості**

У цій лабораторній роботі ми працюємо з кодовими словами довжиною **12 бітів**, які складаються з **8 інформаційних бітів** та **4 перевірочних бітів**, розміщених у позиціях 1, 2, 4 та 8. Коди Хеммінга — це клас лінійних блокових кодів, які дозволяють **виявляти до двох помилок** або **виправляти одну** в кожному кодовому слові. Вони базуються на додаванні перевірочних бітів (parity bits) у певні позиції повідомлення.

### **Побудова Хеммінгового коду**

У цій лабораторній роботі використовується фіксоване значення k = 8 (інформаційні біти). Щоб визначити кількість перевірочних бітів, використовуємо умову:

$$2^r ≥ k + r + 1$$

Підставляємо:

- $k = 8$
- $r = 4$: $2^4 = 16 ≥ 8 + 4 + 1 = 13$ → умова виконується ✅

Таким чином, для 8 інформаційних бітів потрібно 4 перевірочні біти. Загальна довжина кодового слова — 12 бітів.

- Якщо маємо \(k\) інформаційних бітів, додається \(r\) перевірочних бітів, таких що:

$$
2^r \geq k + r + 1
$$

- Перевірочні біти вставляються у позиції, які є ступенями двійки (1, 2, 4, 8, ...).
- Кожен перевірочний біт відповідає за контроль чітності певної підмножини бітів коду.

### **Виправлення помилок**

- При прийомі повідомлення перевірочні біти дозволяють обчислити **синдром** — позицію біта, в якому сталася помилка.
- Якщо синдром = 0 — помилок немає; інакше — виявлена й виправляється одна помилка.

### **Що таке синдром і як його інтерпретувати?**

#### **H-матриця (матриця перевірки) для 12-бітового коду Хеммінга:**

Ця матриця складається з усіх ненульових 4-бітових бінарних чисел — кожен стовпчик відповідає одній позиції у кодовому слові (1–12):

```
H =
[1 0 1 0 1 0 1 0 1 0 1 0]
[0 1 1 0 0 1 1 0 0 1 1 0]
[0 0 0 1 1 1 1 0 0 0 0 1]
[0 0 0 0 0 0 0 1 1 1 1 1]
```

- Рядки — це перевірочні біти (p1, p2, p4, p8)
- Стовпці — позиції в кодовому слові (1–12)

Щоб знайти синдром:

1. Подати отримане кодове слово як вектор-стовпець `r` довжиною 12 біт.
2. Помножити H × r (мод 2)
3. Отримати вектор довжини 4 → це синдром у двійковій формі
4. Перетворити його у десяткове число — це і буде позиція помилки (нумерація з 1)

---

Синдром — це бінарне число, яке показує позицію помилки в кодовому слові. Його обчислюють за допомогою перевірочних бітів:

- кожен перевірочний біт (у позиціях 1, 2, 4, 8, ...) перевіряє парність (парність) окремої підмножини бітів;
- якщо якась перевірка не проходить, відповідний біт у синдромі буде 1;
- результат — це число, яке вказує на **позицію помилкового біта (1-відлік)**.

Приклад:

- якщо синдром = `0000` → помилки немає;
- якщо синдром = `0101` (тобто 5 у десятковій системі) → помилка в 5-му бітові кодового слова.

Для різних наборів даних синдром може бути різним, бо він залежить від розташування конкретної помилки та вмісту кодового слова.

- При прийомі повідомлення перевірочні біти дозволяють обчислити **синдром** — позицію біта, в якому сталася помилка.
- Якщо синдром = 0 — помилок немає; інакше — виявлена й виправляється одна помилка.

## **3. Завдання до виконання**

1. Написати програму, яка будує код Хеммінга з заданого бітового повідомлення.
2. Імітувати випадкову помилку в одному з бітів.
3. Знайти та виправити помилку за допомогою перевірочних бітів.
4. Продемонструвати весь процес кодування, передавання, виявлення і виправлення.

## **4. Вимоги до реалізації**

- Мова програмування: Python або C++.
- Інтерфейс: консольний.
- Вхідні дані: бітовий рядок (наприклад, "1011").
- Обробка виконується поблочно: кожен байт повідомлення (8 бітів) кодується у 12-бітове кодове слово, де 4 біти — перевірочні (у позиціях 1, 2, 4, 8), а 8 — інформаційні (у позиціях 3, 5, 6, 7, 9, 10, 11, 12).
- Вихідні дані:
  - Кодоване повідомлення з перевірочними бітами.
  - Повідомлення з помилкою.
  - Розрахований синдром та позиція помилки.
  - Виправлене повідомлення.

## **5. Приклад тестових даних**

### **Алгоритм побудови 12-бітового коду Хеммінга з одного байта:**

1. Виділити 8 бітів інформаційного байта (наприклад, `01010000`).
2. Створити 12-бітове кодове слово, де позиції **1, 2, 4, 8** зарезервовані для перевірочних бітів, а решта займаються інформаційними:

```
Позиції:   1   2   3   4   5   6   7   8   9  10  11  12
Зміст:     p1  p2  i1  p4  i2  i3  i4  p8  i5  i6  i7  i8
```

3. Розмістити інформаційні біти на позиції: 3, 5, 6, 7, 9, 10, 11, 12.
4. Обчислити значення перевірочних бітів p1, p2, p4, p8 — за правилами парності (XOR бітів у відповідних позиціях).
5. Зібрати всі 12 бітів у фінальне кодове слово.

У цьому прикладі ми демонструємо повний цикл роботи з 12-бітовими кодовими словами, які складаються з 8 інформаційних та 4 перевірочних бітів (розміщених у позиціях 1, 2, 4, 8 відповідно до стандартної побудови коду Хеммінга).
**Вхідне повідомлення:** `Прекрасно!` → у вигляді ASCII-бітів:
```

01010000 01110010 01100101 01101011 01110000 01100001 01110011 01101110 01101111 00100001

```

**Кодування кожного байта окремо:**
- Для кожного 8-бітового символу створити код Хеммінга довжиною 12 біт (8+4).
- Наприклад, `01010000` → `P` → код Хеммінга: `000101000000`

**Імітація помилки в одному кодовому слові:**
- Вибираємо випадкову позицію від 1 до 12 (або задаємо конкретно, як у прикладі — 5-й біт).
- Інвертуємо біт у цій позиції:
  - Якщо було `1` → стане `0`
  - Якщо було `0` → стане `1`
- Отримуємо пошкоджене слово, яке передаємо на етап декодування.
- Наприклад, інвертуємо 5-й біт у коді `011100100000`
- Отримуємо: `011101100000`

**Синдром:**
- Обчислюється за допомогою матриці перевірки (так званої H-матриці), яка відображає вплив кожного біта кодового слова на кожен перевірочний біт. Цей розрахунок можна виконати вручну (аналізуючи парність бітів, що перевіряються) або програмно — шляхом множення кодового слова на H-матрицю за модулем 2 (бітовий XOR). У результаті отримується синдром — бінарне число, яке вказує на позицію помилкового біта (нумерація з 1).
- Визначаємо позицію помилки: наприклад, 5

**Виправлення:**
- Інвертуємо помилковий біт → отримуємо правильне кодове слово.
- Декодуємо усі кодові слова — отримуємо вихідне повідомлення `Прекрасно!`

## **6. Контрольні запитання**
1. Як визначити кількість перевірочних бітів у коді Хеммінга?
2. Яким чином формується синдром?
3. Скільки помилок може виявляти та/або виправляти код Хеммінга?
4. Чому перевірочні біти розміщуються в степенях двійки?


